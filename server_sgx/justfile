#!/usr/bin/env just --justfile

default:
  @just --list


run_pccs:
  #!/usr/bin/env bash
  set -e
  cd /opt/intel/sgx-dcap-pccs
  sudo sed -i '/ApiKey/c\   \"ApiKey\" : \"'$1'\",' default.json 
  sudo npm start pm2 


# Run on SGX hardware
run *args:
  #!/usr/bin/env bash
  set -e

  cargo build --target x86_64-fortanix-unknown-sgx {{args}}

  binpath=`cargo build --target x86_64-fortanix-unknown-sgx {{args}} --message-format json 2>/dev/null \
    | jq -r 'select(.reason=="compiler-artifact" and .target.kind==["bin"]) | .executable'` 

  ftxsgx-elf2sgxs "$binpath" \
    --heap-size 0x4FBA00000 \
    --ssaframesize 1 \
    --stack-size 0x20000 \
    --threads 32

  just generate-manifest-dev "$binpath.sgxs" 
  if [ -d "client/" ]; then
    cp manifest.dev.toml client/blindai/manifest.toml
  else
    cp manifest.dev.toml ../client/blindai/manifest.toml
  fi

  just generate-manifest-prod "$binpath.sgxs" 

  ( cd runner && cargo build --release )

  # ftxsgx-runner "$binpath.sgxs" 

  # Modify the normal runner to the new 
  ./runner/target/release/runner "$binpath.sgxs"
  

run-local-management *args:
  #!/usr/bin/env bash
  set -e

  DISALLOW_REMOTE_UPLOAD="true" cargo build --target x86_64-fortanix-unknown-sgx {{args}}

  binpath=`cargo build --target x86_64-fortanix-unknown-sgx {{args}} --message-format json 2>/dev/null \
    | jq -r 'select(.reason=="compiler-artifact" and .target.kind==["bin"]) | .executable'` 

  ftxsgx-elf2sgxs "$binpath" \
    --heap-size 0x4FBA00000 \
    --ssaframesize 1 \
    --stack-size 0x20000 \
    --threads 32

  just generate-manifest-dev "$binpath.sgxs" 
  if [ -d "client/" ]; then
    cp manifest.dev.toml client/blindai/manifest_cloud.toml
  else
    cp manifest.dev.toml ../client/blindai/manifest_cloud.toml
  fi

  just generate-manifest-prod "$binpath.sgxs" 

  ( cd runner && cargo build --release )

  # ftxsgx-runner "$binpath.sgxs" 

  # Modify the normal runner to the new 
  ./runner/target/release/runner "$binpath.sgxs"

# Build for SGX target
build *args:
  #!/usr/bin/env bash
  set -e
  cargo build --target x86_64-fortanix-unknown-sgx {{args}}

  binpath=`cargo build --target x86_64-fortanix-unknown-sgx {{args}} --message-format json 2>/dev/null \
    | jq -r 'select(.reason=="compiler-artifact" and .target.kind==["bin"]) | .executable'` 
    
  ftxsgx-elf2sgxs "$binpath" \
    --heap-size 0x2FBA00000 \
    --ssaframesize 1 \
    --stack-size 0x20000 \
    --threads 32

  just generate-manifest-dev "$binpath.sgxs" 

  just generate-manifest-prod "$binpath.sgxs" 

  ( cd runner && cargo build --release )

# Check for SGX target
check *args:
  cargo check --target x86_64-fortanix-unknown-sgx {{args}}

# Build for a Linux target (no SGX)
build-no-sgx *args:
  cargo build {{args}}

# Run on a Linux target (no SGX)
run-no-sgx *args:
  cargo run {{args}}

# Run in the simulator
run-simu *args:
  #!/usr/bin/env bash
  set -e

  cargo build --target x86_64-fortanix-unknown-sgx {{args}}

  binpath=`cargo build --target x86_64-fortanix-unknown-sgx {{args}} --message-format json 2>/dev/null \
    | jq -r 'select(.reason=="compiler-artifact" and .target.kind==["bin"]) | .executable'` 
  
  ftxsgx-elf2sgxs "$binpath" \
    --heap-size 0xFBA00000 \
    --ssaframesize 1 \
    --stack-size 0x40000 \
    --threads 32

  just generate-manifest-dev "$binpath.sgxs" 

  just generate-manifest-prod "$binpath.sgxs" 

  ftxsgx-simulator "$binpath.sgxs"

# Execute with valgrind instrumentation
valgrind *args:
  #!/usr/bin/env bash
  set -e

  cargo build --target x86_64-fortanix-unknown-sgx {{args}}

  binpath=`cargo build --target x86_64-fortanix-unknown-sgx {{args}} --message-format json 2>/dev/null \
    | jq -r 'select(.reason=="compiler-artifact" and .target.kind==["bin"]) | .executable'`

  ftxsgx-elf2sgxs "$binpath" \
    --heap-size 0x2000000 \
    --ssaframesize 1 \
    --stack-size 0x20000 \
    --threads 32

  just generate-manifest-dev "$binpath.sgxs" 

  just generate-manifest-prod "$binpath.sgxs" 

  valgrind --sigill-diagnostics=no --leak-check=no ftxsgx-simulator "$binpath.sgxs" 


# generate a manifest.toml for dev purposes, expects path to the sgxs file 
generate-manifest-dev input_sgxs:
  #!/usr/bin/env bash
  set -e
  export mr_enclave=`sgxs-hash {{input_sgxs}}`
  envsubst < manifest.dev.template.toml > manifest.dev.toml

# generate a manifest.toml for prod purposes expects path to the sgxs file
generate-manifest-prod input_sgxs:
  #!/usr/bin/env bash
  set -e
  export mr_enclave=`sgxs-hash {{input_sgxs}}`
  envsubst < manifest.prod.template.toml > manifest.prod.toml
  

release:
  #!/usr/bin/env bash
  set -e 
  set -x

  just build --release
  if [ -d "client/" ]; then
    cp manifest.prod.toml client/blindai/manifest.toml
  else
    cp manifest.prod.toml ../client/blindai/manifest.toml
  fi

  openssl genrsa -3 3072 > my_key.pem
  sgxs-sign --key my_key.pem  target/x86_64-fortanix-unknown-sgx/release/blindai_server.sgxs   target/x86_64-fortanix-unknown-sgx/release/blindai_server.sig   --xfrm 7/0 --isvprodid 0 --isvsvn 0
  ./runner/target/release/runner target/x86_64-fortanix-unknown-sgx/release/blindai_server.sgxs